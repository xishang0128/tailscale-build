diff --git a/tailscale/net/tsaddr/tsaddr.go b/tailscale/net/tsaddr/tsaddr.go
--- a/tailscale/net/tsaddr/tsaddr.go
+++ b/tailscale/net/tsaddr/tsaddr.go
@@ -8,6 +8,7 @@
 	"encoding/binary"
 	"errors"
 	"net/netip"
+	"os"
 	"slices"
 	"sync"
 
@@ -26,12 +27,19 @@
 
 var chromeOSRange oncePrefix
 
+func getrange() string {
+	if os.Getenv("TS_RANGE") != "" {
+		return os.Getenv("TS_RANGE")
+	}
+	return "100.64.0.0/10"
+}
+
 // CGNATRange returns the Carrier Grade NAT address range that
 // is the superset range that Tailscale assigns out of.
 // See https://tailscale.com/s/cgnat
 // Note that Tailscale does not assign out of the ChromeOSVMRange.
 func CGNATRange() netip.Prefix {
-	cgnatRange.Do(func() { mustPrefix(&cgnatRange.v, "100.64.0.0/10") })
+	cgnatRange.Do(func() { mustPrefix(&cgnatRange.v, getrange()) })
 	return cgnatRange.v
 }
 
diff --git a/tailscale/ipn/ipnlocal/ssh.go b/tailscale/ipn/ipnlocal/ssh.go
--- a/tailscale/ipn/ipnlocal/ssh.go
+++ b/tailscale/ipn/ipnlocal/ssh.go
@@ -1,7 +1,7 @@
 // Copyright (c) Tailscale Inc & AUTHORS
 // SPDX-License-Identifier: BSD-3-Clause
 
-//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9
+//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9
 
 package ipnlocal
 
diff --git a/tailscale/ipn/ipnlocal/ssh_stub.go b/tailscale/ipn/ipnlocal/ssh_stub.go
--- a/tailscale/ipn/ipnlocal/ssh_stub.go
+++ b/tailscale/ipn/ipnlocal/ssh_stub.go
@@ -1,7 +1,7 @@
 // Copyright (c) Tailscale Inc & AUTHORS
 // SPDX-License-Identifier: BSD-3-Clause
 
-//go:build ios || android || (!linux && !darwin && !freebsd && !openbsd && !plan9)
+//go:build ios || (!linux && !darwin && !freebsd && !openbsd && !plan9)
 
 package ipnlocal

diff --git a/tailscale/tsd/tsd.go b/tailscale/tsd/tsd.go
--- a/tailscale/tsd/tsd.go
+++ b/tailscale/tsd/tsd.go
@@ -197,13 +197,14 @@ func (p *SubSystem[T]) Set(v T) {
 	if p.set {
 		var oldVal any = p.v
 		var newVal any = v
-		if oldVal == newVal {
-			// Allow setting to the same value.
-			// Note we had to box them through "any" to force them to be comparable.
-			// We can't set the type constraint T to be "comparable" because the interfaces
-			// aren't comparable. (See https://github.com/golang/go/issues/52531 and
-			// https://github.com/golang/go/issues/52614 for some background)
+		switch any(v).(type) {
+		case router.Router:
+			p.v = v
 			return
+		default:
+			if reflect.DeepEqual(oldVal, newVal) {
+				return
+			}
 		}
 
 		var z *T